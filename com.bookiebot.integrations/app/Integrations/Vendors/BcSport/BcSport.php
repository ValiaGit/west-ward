<?php

namespace App\Integrations\BcSport;


use App\Integrations\BcSport\Constants\ErrorCodes;
use App\Integrations\BcSport\Constants\Config;
use App\Integrations\BcSport\Constants\TransactionTypes;

use App\Integrations\Casino\CasinoCoreInterface;
use App\Integrations\Constants\GISErrorCodes;
use App\Integrations\Helpers\GISLogger;
use App\Integrations\Helpers\TokenGenerator;
use App\Integrations\Vendors\GameVendorBase;

use App\Models\Persistence;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;


class BcSport extends GameVendorBase
{

    /**
     * Instance For Communicating Casino Core
     * @var CasinoCoreInterface
     */
    protected $CasinoCore;

    /**
     *
     * @var Persistence
     */
    protected $Persistence;


    /**
     * @var GISLogger
     */
    protected $Logger;


    /**
     * Constructor. - Inject CasinoCore Implementation Details,Persistence,GISLogger
     *
     * BcSport constructor.
     * @param Persistence $persistence
     * @param GISLogger $logger
     */
    public function __construct(Persistence $persistence, GISLogger $logger)
    {

        //Persistence Service Injected
        $this->Persistence = $persistence;

        //Logger Injected
        $this->Logger = $logger;

        //Inject Casino Core Instance
        $this->CasinoCore = $this->getCasinoIntegrationInstance(
            Config::PROVIDER(),
            Config::SECRET()
        );
    }


    /**
     *
     * This method is called when a player loads Sportsbook. Method receives AuthToken generated by OperatorBE server and returns players data in case player is logged in to the OperatorWebSite and token is valid. If user is not logged in, method should return ErrorCode 1008. In case of other problems (for example expired AuthToken or similar) other ErrorCodes should be used.
     *
     * Player currency should match list of currencies, specified in Currency Codes section
     *
     * @SWG\POST(
     *     path="/api/bcsport/GetClientDetails",
     *     summary="This method is called when a player loads Sportsbook",
     *     tags={"BetConstructSport"},
     *     description="This method is called when a player loads Sportsbook. Method receives AuthToken generated by OperatorBE server and returns players data in case player is logged in to the OperatorWebSite and token is valid. If user is not logged in, method should return ErrorCode 1008. In case of other problems (for example expired AuthToken or similar) other ErrorCodes should be used. ",
     *
     *   @SWG\Parameter(
     *     in="body",
     *     name="body",
     *     description="Payload to authenticate user with token",
     *     required=false,
     *     default="{'':''}",
     *     @SWG\Schema(
     *       type="xml",
     *       @SWG\Items()
     *     )
     *   ),
     *
     *
     *
     *     @SWG\Response(
     *         response=200,
     *         description="successful operation",
     *         @SWG\Schema(ref="#/definitions/successModel")
     *     ),
     *     @SWG\Response(
     *         response="400",
     *         description="Invalid request parameters",
     *         @SWG\Schema(ref="#/definitions/errorModel")
     *     ),
     * )
     *
     * @param Request $request
     * @return mixed
     */
    public function GetClientDetails(Request $request) {


        if(!$this->isHashValid($request)) {
            $this->Logger->warn('[BCSPORT] GetClientDetails Hash was invalid');
            return $this->sendError(ErrorCodes::TOKEN_ERROR,'Hash Was not valid');
        }



        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            $requestBody = json_decode($requestBody,true);


            $this->Logger->debug('[BCSPORT] GetClientDetails Received Request',$requestBody);


            $AuthToken = $requestBody['AuthToken'];
            if(!$AuthToken) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',"No Auth Token");
                return $this->sendError(ErrorCodes::API_WRONG_ACCESS,"Wrong request");
            }


            //If Token Was Already Persisted We Just Check
            $check_token_exists = $this->isTokenPersisted($AuthToken);
            if($check_token_exists) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',$check_token_exists);
                return $this->sendSuccess($check_token_exists);
            }



            $userAuthResponse = $this->CasinoCore->auth($AuthToken);

            //If User Was Authenticated Succesfully
            if($userAuthResponse['code'] == GISErrorCodes::SUCCESS) {


                //Grab Use Details
                $userAuthDetails = $userAuthResponse['data'];

                //Save Data in local variables
                $userId = $userAuthDetails['userId'];
                $userName = $userAuthDetails['userName'];
                $currency = $userAuthDetails['currency'];
                $ip = $userAuthDetails['ip'];


                //Success Data
                $success_data = [
                    "Login"=>$userName,
                    "CurrencyId"=>$currency,
                    "ExternalId"=>$userId,
                    "CurrentIp"=>$ip,
                ];



                //Persist Token In Database
                $persist_token = $this->Persistence->persist(Config::PROVIDER().$AuthToken,$success_data);
                if($persist_token == true) {
                    $this->Logger->debug('[BCSPORT] GetClientDetails Success',$success_data);
                    //Respond With Success And User Details
                    return $this->sendSuccess($success_data);
                }

                else {

                    $this->Logger->error('[BCSPORT] GetClientDetails Can not persist data',$success_data);
                    return $this->sendError(ErrorCodes::WRONG_LOGIN_DETAILS,$persist_token);
                }




            }


            //If Token Was Not Valid By Core System
            else {
                $this->Logger->warn('[BCSPORT] GetClientDetails Wrong Auth Token');
                return $this->sendError(ErrorCodes::WRONG_LOGIN_DETAILS,"Provided AuthToken ws not valid");
            }



        }catch(\Exception $e) {
            $this->Logger->error('[BCSPORT] GetClientDetails Exception'.$e->getMessage());
            return $this->sendError(ErrorCodes::INTERNAL_ERROR,$e->getMessage());
        }

    }



    /**
     *
     * This method is used to retrieve current User’s (player’s) balance in player’s currency.
     *
     * @SWG\POST(
     *     path="/api/bcsport/GetClientBalance",
     *     summary="This method is used to retrieve current User’s (player’s) balance in player’s currency.",
     *     tags={"BetConstructSport"},
     *     description="This method is used to retrieve current User’s (player’s) balance in player’s currency.",
     *
     *   @SWG\Parameter(
     *     in="body",
     *     name="body",
     *     description="Payload to request UserBalance",
     *     required=false,
     *     default="",
     *     @SWG\Schema(
     *       type="xml",
     *       @SWG\Items()
     *     )
     *   ),
     *
     *
     *
     *     @SWG\Response(
     *         response=200,
     *         description="successful operation",
     *         @SWG\Schema(ref="#/definitions/successModel")
     *     ),
     *     @SWG\Response(
     *         response="400",
     *         description="Invalid request parameters",
     *         @SWG\Schema(ref="#/definitions/errorModel")
     *     ),
     * )
     *
     * @param Request $request
     * @return mixed
     */
    public function GetClientBalance(Request $request) {


        if(!$this->isHashValid($request)) {
            $this->Logger->warn('[BCSPORT] GetClientBalance Hash was invalid');
            return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Hash Was not valid');
        }

        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            $requestBody = json_decode($requestBody,true);


            $this->Logger->debug('[BCSPORT] GetClientBalance Received Request',$requestBody);

            $authToken = $requestBody['AuthToken'];
            if(!$authToken) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',"No Auth Token");
                return $this->sendError(ErrorCodes::API_WRONG_ACCESS,"Wrong request");
            }
            $timeStamp = $requestBody['TS'];


            //If Token Was Already Persisted We Just Chec
            $checkTokenExists = $this->isTokenPersisted($authToken);
            if(!$checkTokenExists) {
                $this->Logger->warn('[BCSPORT] GetClientBalance Token is not valid');
                return $this->sendError(ErrorCodes::TOKEN_ERROR,'Token is not valid');
            }


            $userId = $checkTokenExists['ExternalId'];
            $currency = $checkTokenExists['CurrencyId'];


            $balance = $this->grabBalance($userId,$currency);
            if(!$balance) {
                $this->Logger->error('[BCSPORT] GetClientBalance Cant determine balance');
                return $this->sendError(ErrorCodes::INTERNAL_ERROR,"Can't retrieve Balance");
            }

            $success_data = [
                'Balance'=>$balance
            ];

            $this->Logger->debug('[BCSPORT] GetClientBalance Success',["balance"=>$success_data,"user"=>$success_data]);
            return $this->sendSuccess($success_data);


        }
        catch(\Exception $e) {
            //TODO Log Exception Happened Data
            $this->Logger->error('[BCSPORT] GetClientBalance Exception: '.$e->getMessage());
            return $this->sendError(ErrorCodes::INTERNAL_ERROR,$e->getMessage());
        }
    }



    /**
     *
     * This method is called by BetConstructBE when User placed a bet
     *
     * @SWG\POST(
     *     path="/api/bcsport/BetPlaced",
     *     summary="This method is called by BetConstructBE when User placed a bet",
     *     tags={"BetConstructSport"},
     *     description="This method is called by BetConstructBE when User placed a bet. The bet is placed in pending status and the call is performed. OperatorBE should validate the placed bet and take money from the player’s account. If there are not enough money, then OperatorBE should return insufficient funds error. In case of any error or communication failure, the placed bet is canceled and an error message displays to User. ",
     *
     *   @SWG\Parameter(
     *     in="body",
     *     name="body",
     *     description="Payload to request Placing Bet",
     *     required=false,
     *     default="",
     *     @SWG\Schema(
     *       type="xml",
     *       @SWG\Items()
     *     )
     *   ),
     *
     *
     *
     *     @SWG\Response(
     *         response=200,
     *         description="successful operation",
     *         @SWG\Schema(ref="#/definitions/successModel")
     *     ),
     *     @SWG\Response(
     *         response="400",
     *         description="Invalid request parameters",
     *         @SWG\Schema(ref="#/definitions/errorModel")
     *     ),
     * )
     *
     * @param Request $request
     * @return mixed
     */
    public function BetPlaced(Request $request) {


        if(!$this->isHashValid($request)) {
            $this->Logger->warn('[BCSPORT] BetPlaced Hash was invalid');
            return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Hash Was not valid');
        }

        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            //Request Body As Array
            $requestBody = json_decode($requestBody,true);

            $this->Logger->debug("[BCSPORT] BetPlaced Request Received",$requestBody);

            //Token Provided By BC
            $authToken = $requestBody['AuthToken'];

            if(!$authToken) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',"No Auth Token");
                return $this->sendError(ErrorCodes::API_WRONG_ACCESS,"Wrong request");
            }

            //Check If Token Was Persisted and we can get User Details
            $checkTokenExists = $this->isTokenPersisted($authToken);
            if(!$checkTokenExists) {
                $this->Logger->warn("[BCSPORT] BetPlaced Wrong Token");
                return $this->sendError(ErrorCodes::TOKEN_ERROR,'Token is not valid');
            }


            //Grab User Details From Token
            $userId = $checkTokenExists['ExternalId'];
            $userCurrency = $checkTokenExists['CurrencyId'];
            $userIp = $checkTokenExists['CurrentIp'];


            //Get Parameters In Local Variables
            $transactionId = isset($requestBody['TransactionId']) ? $requestBody['TransactionId'] : false;
            $betId = isset($requestBody['BetId']) ? $requestBody['BetId'] : false;
            $amount = isset($requestBody['Amount']) ? ($requestBody['Amount']*100) : false;
            $created = isset($requestBody['created']) ? $requestBody['created'] : false;
            $betType = isset($requestBody['betType']) ? $requestBody['betType'] : false;
            $totalPrice = isset($requestBody['totalPrice']) ? $requestBody['TotalPrice'] : false;

            $bonusAmount = isset($requestBody['BonusBetAmount']) ? $requestBody['BonusBetAmount'] : false;
            $bonusId = isset($requestBody['BonusId']) ? $requestBody['BonusId'] : false;


            $selections = "";
            try {
                $selections = json_encode($requestBody['Selections']);
            }catch(\Exception $e) {

            }


            //Additional Descriptions for Bets
            $additionalData = "datetime=$created,betType=$betType,odds=$totalPrice,bonusAmount=$bonusAmount,bonusId=$bonusId,selections=$selections";


            //Call Casino Core To Make Withdrawal
            $withdrawResponse = $this->CasinoCore->withdraw($userId,$amount,$userCurrency,$transactionId,Config::PROVIDER().$transactionId,$userIp,$betId,$additionalData);




            //If Succeed
            if($withdrawResponse['code'] == GISErrorCodes::SUCCESS) {

                $this->Logger->debug("[BCSPORT] BetPlaced Was Success",[
                    "userId"=>$userId,
                    "amount"=>$amount,
                    "userCurrency"=>$userCurrency,
                    "transactionId"=>$transactionId,
                    "userIp"=>$userIp,
                    "betId"=>$betId,
                    "additionalData"=>$additionalData
                ]);

                return $this->sendSuccess();
            }

            //If Failed Withdraw
            else {

                $this->Logger->warn("[BCSPORT] BetPlaced Error",$withdrawResponse);


                if($withdrawResponse['error_code'] == GISErrorCodes::TRANSACTION_ALREADY_EXISTS) {
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Transaction with provided ID already exists');
                }
                else if($withdrawResponse['error_code'] == GISErrorCodes::NOT_SUFFICIENT_FUNDS) {
                    return $this->sendError(ErrorCodes::NOT_SUFFICIENT_BALANCE,'Transaction with provided ID already exists');
                }

                //Unknown General Error
                else {
                    //TODO Log Properly
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Transaction was not proceesed');
                }



            }




        } catch(\Exception $e) {

            //TODO Log Exception Happened Data

            $this->Logger->error("[BCSPORT] BetPlaced Exception: ".$e->getMessage());

            return $this->sendError(ErrorCodes::INTERNAL_ERROR,$e->getMessage());
        }
    }



    /**
     *
     * This method is called by BetConstructBE when an accepted bet is resulted
     *
     * @SWG\POST(
     *     path="/api/bcsport/BetResulted",
     *     summary="This method is called by BetConstructBE when an accepted bet is resulted ",
     *     tags={"BetConstructSport"},
     *     description="This method is called by BetConstructBE when an accepted bet is resulted (bet status is changed). This call is used by OperatorBE to increase User’s account balance by won amount. This can occur when: 1) user bet was rejected or returned and amount is returned to user account 2) user bet won 3) user bet lost and BetConstructBE notifies that bet lost (amount is 0 in this case) 4)	user bet is cashed-out (amount is calculated by BetConstructBE and usually it is less than the bet stake amount)  ",
     *
     *   @SWG\Parameter(
     *     in="body",
     *     name="body",
     *     description="Payload to request Placing Bet",
     *     required=false,
     *     default="",
     *     @SWG\Schema(
     *       type="xml",
     *       @SWG\Items()
     *     )
     *   ),
     *
     *
     *
     *     @SWG\Response(
     *         response=200,
     *         description="successful operation",
     *         @SWG\Schema(ref="#/definitions/successModel")
     *     ),
     *     @SWG\Response(
     *         response="400",
     *         description="Invalid request parameters",
     *         @SWG\Schema(ref="#/definitions/errorModel")
     *     ),
     * )
     *
     * @param Request $request
     * @return mixed
     */
    public function BetResulted(Request $request) {



        if(!$this->isHashValid($request)) {

            $this->Logger->warn('[BCSPORT] BetResulted Hash was invalid');

            return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Hash Was not valid');
        }

        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            $requestBody = json_decode($requestBody,true);


            $this->Logger->debug('[BCSPORT] BetResulted Received Request',$requestBody);

            $authToken = $requestBody['AuthToken'];

            if(!$authToken) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',"No Auth Token");
                return $this->sendError(ErrorCodes::API_WRONG_ACCESS,"Wrong request");
            }


            //If Token Was Already Persisted We Just Check
            $checkTokenExists = $this->isTokenPersisted($authToken);
            if(!$checkTokenExists) {
                $this->Logger->warn('[BCSPORT] BetResulted Wrong Token');
                return $this->sendError(ErrorCodes::TOKEN_ERROR,'Token is not valid');
            }

            //Grab User Details From Token
            $userId = $checkTokenExists['ExternalId'];
            $userCurrency = $checkTokenExists['CurrencyId'];
            $userIp = $checkTokenExists['CurrentIp'];

            //Get Bet Values in Local Variables
            $transactionId = isset($requestBody['TransactionId']) ? $requestBody['TransactionId'] : false;
            $betId = isset($requestBody['BetId']) ? $requestBody['BetId'] : false;
            $amount = isset($requestBody['Amount']) ? ($requestBody['Amount']*100) : false;
            $betState = isset($requestBody['BetState']) ? $requestBody['BetState'] : false;
            $isLive = isset($requestBody['IsLive']) ? $requestBody['IsLive'] : false;
            $bonusAmount = isset($requestBody['BonusAmount']) ? $requestBody['BonusAmount'] : false;
            $bonusId = isset($requestBody['BonusId']) ? $requestBody['BonusId'] : false;
            $additionalData = "betState=$betState,isLive=$isLive,bonusAmount=$bonusAmount,bonusId=$bonusId";


            //Send Deposit Request To Casino Core System
            $depositResponse = $this->CasinoCore->deposit($userId,$amount,$userCurrency,$transactionId,Config::PROVIDER().$transactionId,$userIp,$betId,$additionalData);


            //If Casino Responded With Successful Transaction
            if($depositResponse['code'] == GISErrorCodes::SUCCESS) {

                //Transaction Details
                $transactionId = $depositResponse['data']['casinoTransactionId'];
                $external_success_code = $depositResponse['external_success_code'];


                $this->Logger->warn('[BCSPORT] BetResulted Success', [
                    "userId"=>$userId,
                    "amount"=>$amount,
                    "userCurrency"=>$userCurrency,
                    "transactionId"=>$transactionId,
                    "userIp"=>$userIp,
                    "betId"=>$betId,
                    "additionalData"=>$additionalData
                ]);

                //Send Successful Transaction
                return $this->sendSuccess();


            }

            //If Transaction Failed
            else {

                $this->Logger->warn('[BCSPORT] BetResulted Failed in Core', $depositResponse);

                //If Duplicate Transaction Error Responded
                if($depositResponse['error_code'] == GISErrorCodes::TRANSACTION_ALREADY_EXISTS) {
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'TransactionId is duplicated');
                }

                //Unknown Error Also Log Properly
                else {
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Transaction was not proceesed. ExternalError='.json_encode($depositResponse));
                }


            }




        }

        catch(\Exception $e) {

            $this->Logger->warn('[BCSPORT] BetResulted Exception: '.$e->getMessage());

            //TODO Log Exception Happened Data
            return $this->sendError(ErrorCodes::INTERNAL_ERROR,$e->getMessage());
        }
    }



    /**
     *
            This method is called by BetConstructBE when any transaction (placed bet, winning info, etc.) needs to be canceled.
            This can occur when:
                ●	user placed bet is waiting for Operator confirmation and the BetPlaced call fails or some communication error happens and the bet cannot be accepted.
                ●	A calculated winning amount is canceled or reverted due to match results.
            OperatorBE can kindly ignore this message if the transaction by this ID had not been processed before.
     *
     * @SWG\POST(
     *     path="/api/bcsport/Rollback",
     *     summary="This method is called by BetConstructBE when any transaction (placed bet, winning info, etc.) needs to be canceled.",
     *     tags={"BetConstructSport"},
     *     description="This method is called by BetConstructBE when any transaction (placed bet, winning info, etc.) needs to be canceled.",
     *
     *   @SWG\Parameter(
     *     in="body",
     *     name="body",
     *     description="Payload to request Placing Bet",
     *     required=false,
     *     default="",
     *     @SWG\Schema(
     *       type="xml",
     *       @SWG\Items()
     *     )
     *   ),
     *
     *
     *
     *     @SWG\Response(
     *         response=200,
     *         description="successful operation",
     *         @SWG\Schema(ref="#/definitions/successModel")
     *     ),
     *     @SWG\Response(
     *         response="400",
     *         description="Invalid request parameters",
     *         @SWG\Schema(ref="#/definitions/errorModel")
     *     ),
     * )
     *
     * @param Request $request
     * @return mixed
     */
    public function Rollback(Request $request) {


        if(!$this->isHashValid($request)) {

            $this->Logger->warn('[BCSPORT] Rollback Hash was invalid');

            return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Hash Was not valid');
        }

        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            $requestBody = json_decode($requestBody,true);

            $this->Logger->debug('[BCSPORT] Rollback Received',$requestBody);


            $authToken = $requestBody['AuthToken'];

            if(!$authToken) {
                $this->Logger->debug('[BCSPORT] GetClientDetails Success',"No Auth Token");
                return $this->sendError(ErrorCodes::API_WRONG_ACCESS,"Wrong request");
            }

            //If Token Was Already Persisted We Just Chec
            $checkTokenExists = $this->isTokenPersisted($authToken);
            if(!$checkTokenExists) {
                $this->Logger->warn('[BCSPORT] Rollback Wrong Token');
                return $this->sendError(ErrorCodes::TOKEN_ERROR,'Token is not valid');
            }


            $transactionId = isset($requestBody['TransactionId']) ? $requestBody['TransactionId'] : false;

            $rollbackResponse = $this->CasinoCore->rollback($transactionId);
            if($rollbackResponse['code'] == GISErrorCodes::SUCCESS) {

                $this->Logger->debug('[BCSPORT] Rollback Succeed',[
                    "Token"=>$checkTokenExists,
                    "Response"=>$rollbackResponse
                ]);

                return $this->sendSuccess();
            }
            else {

                $this->Logger->warn('[BCSPORT] Rollback Failed in Core',$rollbackResponse);

                if($rollbackResponse['error_code'] == GISErrorCodes::TRANSACTION_NOT_FOUND) {
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Transaction was not found to make rollback');
                }
                else {
                    return $this->sendError(ErrorCodes::INTERNAL_ERROR,'Transaction was not rolledback');
                }



            }



        }catch(\Exception $e) {
            //TODO Log Exception Happened Data

            $this->Logger->error('[BCSPORT] Rollback Exception thrown: '.$e->getMessage());

            return $this->sendError(ErrorCodes::INTERNAL_ERROR,$e->getMessage());
        }
    }



    /**
     * @param Request $request
     * @return boolean
     */
    private function isHashValid(Request $request)
    {

        return true;
        try {

            //Grab Request Parameters as Array
            $requestBody = $request->getContent();
            $requestBody = json_decode($requestBody,true);
            print_r($requestBody);


            $hashString = "";
            foreach($requestBody as $key=>$value) {
                if($key!='Hash' && $value) {
                    if(gettype($value) == 'array') {
                        $value = json_encode($value);
                    }
                    $hashString.=$key.$value;
                }
            }
            $hashString.=Config::KEY();



            if(md5($hashString) ==  $requestBody['Hash']) {
                return false;
            }


        }catch(\Exception $e) {
            echo $e->getMessage();
            return false;
        }


        return false;
    }


    /**
     * @param $code
     * @param $description
     * @return mixed
     */
    private function sendError($code, $description) {

        $return_data = [
            'ErrorCode'=>$code,
            'ErrorText'=>$description
        ];




        return $return_data;
    }



    /**
     * Sends Success Response To BetConstruct
     * @param $data
     * @return array
     */
    private function sendSuccess($data = []) {
        $return_data = array_merge($data,[
            'ErrorText'=>"",
            'ErrorCode'=>0
        ]);


        return $return_data;
    }


    /**
     * @param $token
     * @return bool|mixed
     */
    private function isTokenPersisted($token) {
        try {
            $exists = $this->Persistence->check(Config::PROVIDER().$token);
            if($exists) {
                return $exists;
            }
            else {
                return false;
            }
        }catch(\Exception $e) {
            return false;
        }

    }






}